# backend/services/face_service.py
"""
Face recognition service using face descriptor comparison.
This service stores and compares 128-dimensional face descriptors generated by face-api.js
"""
import numpy as np
from typing import List, Dict, Optional, Tuple
import base64
from io import BytesIO
from PIL import Image
import cv2


def euclidean_distance(descriptor1: List[float], descriptor2: List[float]) -> float:
    """
    Calculate Euclidean distance between two face descriptors.
    Lower distance means more similar faces.
    """
    arr1 = np.array(descriptor1)
    arr2 = np.array(descriptor2)
    return np.linalg.norm(arr1 - arr2)


def compare_faces(known_descriptor: List[float], unknown_descriptor: List[float], 
                  threshold: float = 0.6) -> Tuple[bool, float]:
    """
    Compare two face descriptors and determine if they match.
    
    Args:
        known_descriptor: The stored face descriptor
        unknown_descriptor: The face descriptor to compare
        threshold: Maximum distance to consider a match (default 0.6)
    
    Returns:
        Tuple of (is_match, distance)
    """
    distance = euclidean_distance(known_descriptor, unknown_descriptor)
    is_match = distance < threshold
    return is_match, distance


def find_best_match(face_descriptor: List[float], employees: List[Dict], 
                    threshold: float = 0.6) -> Optional[Dict]:
    """
    Find the best matching employee for a given face descriptor.
    Supports both single descriptor and multiple descriptors per employee.
    
    Args:
        face_descriptor: The face descriptor to match
        employees: List of employee documents with face_descriptor or face_descriptors field
        threshold: Maximum distance to consider a match
    
    Returns:
        Dictionary with employee info and confidence, or None if no match
    """
    best_match = None
    best_distance = float('inf')
    
    for employee in employees:
        if not employee.get('face_registered'):
            continue
        
        # Support both single descriptor (old format) and multiple descriptors (new format)
        stored_descriptors = []
        if 'face_descriptors' in employee and isinstance(employee['face_descriptors'], list):
            # New format: array of descriptors
            stored_descriptors = employee['face_descriptors']
        elif 'face_descriptor' in employee:
            # Old format: single descriptor - convert to list
            stored_descriptors = [employee['face_descriptor']]
        
        if not stored_descriptors:
            continue
        
        # Check against all descriptors for this employee, take the best match
        employee_best_distance = float('inf')
        for stored_descriptor in stored_descriptors:
            distance = euclidean_distance(face_descriptor, stored_descriptor)
            if distance < employee_best_distance:
                employee_best_distance = distance
        
        # If this employee's best match is better than global best, update
        if employee_best_distance < threshold and employee_best_distance < best_distance:
            best_distance = employee_best_distance
            best_match = employee
    
    if best_match:
        # Convert distance to confidence score (0-1, higher is better)
        # Distance of 0 = confidence 1.0, distance of threshold = confidence 0.0
        confidence = max(0, 1 - (best_distance / threshold))
        
        return {
            'employee_id': str(best_match.get('_id', '')),
            'employee_name': best_match.get('name', 'Unknown'),
            'store_id': best_match.get('store_id', ''),
            'role': best_match.get('role', ''),
            'confidence': round(confidence, 3),
            'distance': round(best_distance, 3)
        }
    
    return None


def validate_face_descriptor(descriptor: List[float]) -> bool:
    """
    Validate that a face descriptor has the correct format.
    Face-api.js generates 128-dimensional descriptors.
    """
    if not isinstance(descriptor, (list, tuple)):
        return False
    
    if len(descriptor) != 128:
        return False
    
    # Check that all values are numbers
    try:
        for val in descriptor:
            float(val)
        return True
    except (ValueError, TypeError):
        return False


def decode_base64_image(base64_string: str) -> Optional[np.ndarray]:
    """
    Decode a base64 image string to numpy array.
    
    Args:
        base64_string: Base64 encoded image (with or without data URI prefix)
    
    Returns:
        Numpy array of the image, or None if decoding fails
    """
    try:
        # Remove data URI prefix if present
        if ',' in base64_string:
            base64_string = base64_string.split(',')[1]
        
        # Decode base64
        image_data = base64.b64decode(base64_string)
        
        # Convert to PIL Image
        image = Image.open(BytesIO(image_data))
        
        # Convert to numpy array
        image_array = np.array(image)
        
        # Convert RGB to BGR for OpenCV if needed
        if len(image_array.shape) == 3 and image_array.shape[2] == 3:
            image_array = cv2.cvtColor(image_array, cv2.COLOR_RGB2BGR)
        
        return image_array
    except Exception as e:
        print(f"Error decoding base64 image: {e}")
        return None


def compress_image(base64_string: str, max_size: int = 500) -> str:
    """
    Compress and resize an image for storage.
    
    Args:
        base64_string: Base64 encoded image
        max_size: Maximum width/height in pixels
    
    Returns:
        Compressed base64 image string
    """
    try:
        # Remove data URI prefix if present
        prefix = ""
        if ',' in base64_string:
            prefix, base64_string = base64_string.split(',', 1)
            prefix += ','
        
        # Decode base64
        image_data = base64.b64decode(base64_string)
        
        # Convert to PIL Image
        image = Image.open(BytesIO(image_data))
        
        # Resize if needed
        if max(image.size) > max_size:
            ratio = max_size / max(image.size)
            new_size = tuple(int(dim * ratio) for dim in image.size)
            image = image.resize(new_size, Image.Resampling.LANCZOS)
        
        # Convert to JPEG and compress
        buffer = BytesIO()
        image.convert('RGB').save(buffer, format='JPEG', quality=85, optimize=True)
        
        # Encode back to base64
        compressed_b64 = base64.b64encode(buffer.getvalue()).decode('utf-8')
        
        return prefix + compressed_b64
    except Exception as e:
        print(f"Error compressing image: {e}")
        return base64_string  # Return original if compression fails
